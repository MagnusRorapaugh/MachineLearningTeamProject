import numpy as np
from PIL import Image
import os
import time as tm
import random

# for the edges, adds a buffer with no holes/nubs
# tile = tile to add the buffer to
# up = if buffer should be above the tile (if False, then below)
# left = if buffer should be to the left of the tile (if False, then on right)
def bufferEdge(tile, up, down, left, right, non_rgb):
    buffer = np.full((len(tile),4,3),non_rgb)
    if left:
        tile = np.append((buffer), tile, axis=1)
    if right:
        tile = np.append((tile), buffer, axis=1)
    buffer = np.full((4,len(tile[0]),3),non_rgb)
    if up:
        tile = np.vstack((buffer, tile))
    if down:
        tile = np.vstack((tile, buffer))
    return tile

# adds a nob and a hole to the tiles going left/right. This is hideous, I hate it, and I can't be bothered to fix it
# tile_L = tile on the left
# tile_R = tile on the right
# non_rgb = value to input as a non-pixel (the "color" in the hole, currently -1)
# left = if the nub is pointing left (hole on the right piece)
# returns the new left tile, new right tile
def nobHoriz(tile_L, tile_R, non_rgb, left):
    # sets which piece has the nub and randomizes the height of the nob
    topOfNub = random.randrange(len(tile_R)-3)
    tile_nub = tile_L
    tile_hole = tile_R
    index = 0
    if left:
        tile_nub = tile_R
        tile_hole = tile_L
        index = len(tile_hole[0])-4
    # create the nob
    buffer = np.full((len(tile_nub),4,3),non_rgb)
    buffer[topOfNub][1]=tile_hole[topOfNub][index+1]
    buffer[topOfNub][2]=tile_hole[topOfNub][index+2]
    buffer[topOfNub+1][0]=tile_hole[topOfNub+1][index+0]
    buffer[topOfNub+1][1]=tile_hole[topOfNub+1][index+1]
    buffer[topOfNub+1][2]=tile_hole[topOfNub+1][index+2]
    buffer[topOfNub+1][3]=tile_hole[topOfNub+1][index+3]
    buffer[topOfNub+2][0]=tile_hole[topOfNub+2][index+0]
    buffer[topOfNub+2][1]=tile_hole[topOfNub+2][index+1]
    buffer[topOfNub+2][2]=tile_hole[topOfNub+2][index+2]
    buffer[topOfNub+2][3]=tile_hole[topOfNub+2][index+3]
    buffer[topOfNub+3][1]=tile_hole[topOfNub+3][index+1]
    buffer[topOfNub+3][2]=tile_hole[topOfNub+3][index+2]
    # remove the hole
    tile_hole[topOfNub][index+1]=non_rgb
    tile_hole[topOfNub][index+2]=non_rgb
    tile_hole[topOfNub+1][index+0]=non_rgb
    tile_hole[topOfNub+1][index+1]=non_rgb
    tile_hole[topOfNub+1][index+2]=non_rgb
    tile_hole[topOfNub+1][index+3]=non_rgb
    tile_hole[topOfNub+2][index+0]=non_rgb
    tile_hole[topOfNub+2][index+1]=non_rgb
    tile_hole[topOfNub+2][index+2]=non_rgb
    tile_hole[topOfNub+2][index+3]=non_rgb
    tile_hole[topOfNub+3][index+1]=non_rgb
    tile_hole[topOfNub+3][index+2]=non_rgb
    # add the buffer and nob, return left tile and right tile
    if left:
        tile_nub = np.append((buffer), tile_nub, axis=1)
        buffer = np.full((len(tile_hole),4,3),non_rgb)
        tile_hole = np.append((tile_hole), buffer, axis=1)
        return tile_hole.astype(np.uint8), tile_nub.astype(np.uint8)
    else:
        tile_nub = np.append((tile_nub), buffer, axis=1)
        buffer = np.full((len(tile_hole),4,3),non_rgb)
        tile_hole = np.append((buffer), tile_hole, axis=1)
    return tile_nub.astype(np.uint8), tile_hole.astype(np.uint8)
        

# adds a nob and a hole to the tiles going up/down. Again, hideous
# tile_A = tile above
# tile_B = tile below
# non_rgb = value to input as a non-pixel (the "color" in the hole, currently -1)
# up = if the nub is pointing up (hole on the topmost piece)
# returns the new top tile, new bottom tile
def nobVert(tile_A, tile_B, non_rgb, up):
    # sets which piece has the nub and randomize the side to side of nub
    leftOfNub = random.randrange(len(tile_B[0])-3)
    tile_nub = tile_A
    tile_hole = tile_B
    if up:
        tile_nub = tile_B
        tile_hole = tile_A
    buffer = np.full((4,len(tile_nub[0]),3),non_rgb)
    index = 0
    if up:
        index=len(tile_hole)-4
    # create the nob
    buffer[1][leftOfNub]=tile_hole[index+1][leftOfNub]
    buffer[2][leftOfNub]=tile_hole[index+2][leftOfNub]
    buffer[0][leftOfNub+1]=tile_hole[index+0][leftOfNub+1]
    buffer[1][leftOfNub+1]=tile_hole[index+1][leftOfNub+1]
    buffer[2][leftOfNub+1]=tile_hole[index+2][leftOfNub+1]
    buffer[3][leftOfNub+1]=tile_hole[index+3][leftOfNub+1]
    buffer[0][leftOfNub+2]=tile_hole[index+0][leftOfNub+2]
    buffer[1][leftOfNub+2]=tile_hole[index+1][leftOfNub+2]
    buffer[2][leftOfNub+2]=tile_hole[index+2][leftOfNub+2]
    buffer[3][leftOfNub+2]=tile_hole[index+3][leftOfNub+2]
    buffer[1][leftOfNub+3]=tile_hole[index+1][leftOfNub+3]
    buffer[2][leftOfNub+3]=tile_hole[index+2][leftOfNub+3]
    # remove the hole
    tile_hole[index+1][leftOfNub]=non_rgb
    tile_hole[index+2][leftOfNub]=non_rgb
    tile_hole[index+0][leftOfNub+1]=non_rgb
    tile_hole[index+1][leftOfNub+1]=non_rgb
    tile_hole[index+2][leftOfNub+1]=non_rgb
    tile_hole[index+3][leftOfNub+1]=non_rgb
    tile_hole[index+0][leftOfNub+2]=non_rgb
    tile_hole[index+1][leftOfNub+2]=non_rgb
    tile_hole[index+2][leftOfNub+2]=non_rgb
    tile_hole[index+3][leftOfNub+2]=non_rgb
    tile_hole[index+1][leftOfNub+3]=non_rgb
    tile_hole[index+2][leftOfNub+3]=non_rgb
    # add the buffer and nob, return top tile and bottom tile
    if up:
        tile_nub = np.vstack((buffer, tile_nub))
        buffer = np.full((4,len(tile_hole[0]),3),non_rgb)
        tile_hole = np.vstack((tile_hole, buffer))
        return tile_hole.astype(np.uint8),tile_nub.astype(np.uint8)
    else:
        tile_nub = np.vstack((tile_nub, buffer))
        buffer = np.full((4,len(tile_hole[0]),3),non_rgb)
        tile_hole = np.vstack((buffer, tile_hole))
    return tile_nub.astype(np.uint8),tile_hole.astype(np.uint8)
 
# creates all the side nobs/holes
# tiles = origonal pieces, no buffer or pads
# non_rgb = value for nonpixel color
# returns the array of pieces with buffering/nobs/holes to the sides only
def sideNobs(tiles, non_rgb):
    side_nub = np.full((len(tiles),len(tiles[0]),len(tiles[0][0]),len(tiles[0][0][0])+8,3),-1)
    i = 0
    while i<len(tiles):
        j = 0
        while j<len(tiles[0]):
            if j == 0:
                temp = bufferEdge(tiles[i][j], False, False, True, False, non_rgb)
                side_nub[i][j],temp = nobHoriz(temp, tiles[i][j+1], non_rgb, bool(random.getrandbits(1)))
            elif j == len(tiles[0])-1:
                side_nub[i][j] = bufferEdge(temp, False, False, False, True, non_rgb)
            else:
                side_nub[i][j],temp = nobHoriz(temp, tiles[i][j+1], non_rgb, bool(random.getrandbits(1)))
            j+=1
        i+=1
    return side_nub.astype(np.uint8)

# creates all the top nobs/holes
# side_nub = pieces with side nobs/holes, buffers added to the sides
# non_rgb = value for nonpixel color
# returns the array of pieces with buffering/nobs/holes in all directions
def topNobs(side_nub, non_rgb):
    pieces = np.full((len(side_nub),len(side_nub[0]),len(side_nub[0][0])+8,len(side_nub[0][0][0]),3),-1)
    j = 0
    while j<len(side_nub[0]):
        i = 0
        while i<len(side_nub):
            if i == 0:
                temp = bufferEdge(side_nub[i][j], True, False, False, False, non_rgb)
                pieces[i][j],temp = nobVert(temp, side_nub[i+1][j], non_rgb, bool(random.getrandbits(1)))
            elif i == len(side_nub)-1:
                pieces[i][j] = bufferEdge(temp, False, True, False, False, non_rgb)
            else:
                pieces[i][j],temp = nobVert(temp, side_nub[i+1][j], non_rgb, bool(random.getrandbits(1)))
            i+=1
        j+=1
    return pieces.astype(np.uint8)    

# trims the image to a certain size, with a certain number of pieces in a row, the returns a numpy array where [0][0] is a piece, and 
# contains each pixel in the pieces rgb value. Recommend using a standardized value for dimensions_of_pixels and pieces_in_row so all 
# pieces are the same size and square. dimensions_of_pixels=1000 and pieces_in_row=10 seems to work well, leaves each piece with 
# 100x100 pixels (with 3 rgb values) in a puzzle with 100 pieces, 10x10.
def processImage(name, dimensions_of_pixels, pieces_in_row, pixels_per_piece):
    image = Image.open(name)
    image = image.resize((dimensions_of_pixels,dimensions_of_pixels))
    arr = np.asarray(image)
    tiles = np.full((pieces_in_row,pieces_in_row,pixels_per_piece,pixels_per_piece,3),0)
    a = np.split(arr,pieces_in_row,axis=0) #splits image into the appropriately shaped rows
    a = np.array(a)
    for i in range(len(a)):
        tiles[i]=np.split(a[i],pieces_in_row,axis=1) #splits and saves the rows into appropriately shaped columns
    non_rgb = -1
    side_pieces = sideNobs(tiles, non_rgb)
    pieces = topNobs(side_pieces, non_rgb)
    return pieces.astype(np.uint8) #must be type uint8 to show image
    
# runs the methods to gather all the data to train on, for however many sample there are. Make sure the location of the images is in the same 
# place as this program so os.listdir() can grab it. Returns nothing as all puzzle pieces are stored in a directory.
def getSamplePieces():
    final_number_of_pixels_per_piece = 200 #for example. The absolute final number of pixels you want in each piece
    number_of_pieces = 5 #for example
    dimensions_of_pixels = (final_number_of_pixels_per_piece-8)*number_of_pieces
    
    pixels_per_piece = final_number_of_pixels_per_piece-8
    path = "Sample_Images/"
    
    files = os.listdir(path)
    for i in files:
        if ".jpeg" not in i and ".jpg" not in i:
            files.remove(i)
    all_images = np.full((len(files), number_of_pieces, number_of_pieces, final_number_of_pixels_per_piece, final_number_of_pixels_per_piece, 3), 0)

    # runs all the images and saves them, this is about 3000 images, so will take a few minutes
    for i in range(len(files)):
        tiles = processImage(path + files[i], dimensions_of_pixels, pieces_in_row, pixels_per_piece)
        all_images[i]=tiles
    return all_images.astype(np.uint8) #must be type uint8 to show image

####################################################################################################################################################################
# temporary?
# Samples with varying sizes, randomly assigned but controllable. Returns a dictionary, key being the number of the puzzle, value the puzzle as a varying size numpy 
# array, same format as previous.
def getSamplePuzzleWithInputSize(final_number_of_pixels_per_piece, number_of_pieces, name):
    dimensions_of_pixels = (final_number_of_pixels_per_piece-8)*number_of_pieces
    pixels_per_piece = final_number_of_pixels_per_piece-8
    tiles = processImage(name, dimensions_of_pixels, pieces_in_row, pixels_per_piece)
    return tiles.astype(np.uint8) #must be type uint8 to show image
def getAllPuzzles():
    path = "Sample_Images/"
    files = os.listdir(path)
    for i in files:
        if ".jpeg" not in i and ".jpg" not in i:
            files.remove(i)
    max_pieces = 6
    max_pixels = 300
    dictionary_of_puzzles = {}
    for i in range(len(files)):
        dictionary_of_puzzles[i]=getSamplePuzzleWithInputSize(random.randrange(max_pixels), random.randrange(max_pieces), path+files[i])
    return dictionary_of_puzzles
    
start_time = tm.time()
all_images = getSamplePieces()
t = tm.time()-start_time
print("Took", int(t/60), "minutes and", "{:.2f}".format(t - 60*int(t/60)), "seconds to gather the training data")
